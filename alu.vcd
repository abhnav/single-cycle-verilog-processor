$date
	Mon Apr 17 03:56:12 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module aggregateALL $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 1 # writeSP $end
$var wire 1 $ writeRegSourceSelect $end
$var wire 1 % writeReg $end
$var wire 1 & writeDataMem $end
$var wire 8 ' spout [7:0] $end
$var wire 9 ( pcaddress [8:0] $end
$var wire 1 ) instructJump $end
$var wire 1 * instructBranch $end
$var wire 4 + flagout [3:0] $end
$var wire 4 , flagin [3:0] $end
$var wire 16 - dataMemin [15:0] $end
$var wire 2 . dataMemAddressSelect [1:0] $end
$var wire 16 / aluin [15:0] $end
$var wire 3 0 aluOp [2:0] $end
$var wire 2 1 aluB [1:0] $end
$var wire 2 2 aluA [1:0] $end
$var wire 16 3 I [15:0] $end
$var wire 16 4 Des [15:0] $end
$var wire 16 5 B [15:0] $end
$var wire 16 6 A [15:0] $end
$var reg 16 7 IMdatain [15:0] $end
$var reg 1 8 writeInstructionMem $end
$scope module ALUuut $end
$var wire 16 9 onefix [15:0] $end
$var wire 4 : shftamnt [3:0] $end
$var wire 8 ; stackaddress [7:0] $end
$var wire 16 < s2 [15:0] $end
$var wire 16 = s1 [15:0] $end
$var wire 16 > res [15:0] $end
$var wire 4 ? flags [3:0] $end
$var wire 16 @ extendedstackaddress [15:0] $end
$var wire 16 A extendedshftamnt [15:0] $end
$var wire 16 B d [15:0] $end
$var wire 3 C aluOp [2:0] $end
$var wire 2 D aluB [1:0] $end
$var wire 2 E aluA [1:0] $end
$var wire 16 F B [15:0] $end
$var wire 16 G A [15:0] $end
$scope module aluUnit $end
$var wire 16 H B [15:0] $end
$var wire 3 I ALUOp [2:0] $end
$var wire 16 J A [15:0] $end
$var reg 1 K carry $end
$var reg 4 L flags [3:0] $end
$var reg 16 M res [15:0] $end
$var reg 16 N temp [15:0] $end
$upscope $end
$scope module selA $end
$var wire 16 O b [15:0] $end
$var wire 16 P c [15:0] $end
$var wire 16 Q d [15:0] $end
$var wire 2 R sel [1:0] $end
$var wire 16 S a [15:0] $end
$var reg 16 T out [15:0] $end
$upscope $end
$scope module selB $end
$var wire 16 U a [15:0] $end
$var wire 16 V d [15:0] $end
$var wire 2 W sel [1:0] $end
$var wire 16 X c [15:0] $end
$var wire 16 Y b [15:0] $end
$var reg 16 Z out [15:0] $end
$upscope $end
$upscope $end
$scope module CUuut $end
$var wire 3 [ aluOp [2:0] $end
$var wire 8 \ It [7:0] $end
$var wire 16 ] I [15:0] $end
$var reg 2 ^ aluA [1:0] $end
$var reg 2 _ aluB [1:0] $end
$var reg 2 ` dataMemAddressSelect [1:0] $end
$var reg 1 * instructBranch $end
$var reg 1 ) instructJump $end
$var reg 1 & writeDataMem $end
$var reg 1 % writeReg $end
$var reg 1 $ writeRegSourceSelect $end
$var reg 1 # writeSP $end
$scope module alucontroller $end
$var wire 3 a aluOp [2:0] $end
$var wire 16 b I [15:0] $end
$upscope $end
$upscope $end
$scope module DMuut $end
$var wire 1 ! clk $end
$var wire 2 c dataMemAddressSelect [1:0] $end
$var wire 1 " rst $end
$var wire 1 & writeDataMem $end
$var wire 8 d stackaddress [7:0] $end
$var wire 8 e finaladdress [7:0] $end
$var wire 16 f dataout [15:0] $end
$var wire 16 g datain [15:0] $end
$var wire 16 h customload [15:0] $end
$var wire 16 i I [15:0] $end
$scope module dmem $end
$var wire 1 ! clk $end
$var wire 16 j dataout [15:0] $end
$var wire 1 " rst $end
$var wire 1 & writeDataMem $end
$var wire 16 k datain [15:0] $end
$var wire 8 l address [7:0] $end
$upscope $end
$scope module selectaddress $end
$var wire 8 m a [7:0] $end
$var wire 8 n b [7:0] $end
$var wire 8 o d [7:0] $end
$var wire 2 p sel [1:0] $end
$var wire 8 q c [7:0] $end
$var reg 8 r out [7:0] $end
$upscope $end
$upscope $end
$scope module IMuut $end
$var wire 1 ! clk $end
$var wire 16 s datain [15:0] $end
$var wire 16 t dataout [15:0] $end
$var wire 1 " rst $end
$var wire 1 8 writeInstructionMem $end
$var wire 9 u address [8:0] $end
$upscope $end
$scope module PCuut $end
$var wire 16 v I [15:0] $end
$var wire 1 w branchselection $end
$var wire 1 ! clk $end
$var wire 1 * instructBranch $end
$var wire 1 ) instructJump $end
$var wire 1 " rst $end
$var wire 1 x zeroflag $end
$var wire 9 y shortjump [8:0] $end
$var wire 9 z pcorjump [8:0] $end
$var wire 9 { pcnextaddress [8:0] $end
$var wire 9 | pcaddress [8:0] $end
$var wire 9 } beqaddresstrimmed [8:0] $end
$var wire 16 ~ beqaddress [15:0] $end
$var wire 9 !" addedpc [8:0] $end
$scope module pc $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 9 "" addrout [8:0] $end
$var wire 9 #" addrin [8:0] $end
$var reg 9 $" curaddress [8:0] $end
$upscope $end
$scope module pcadd $end
$var wire 9 %" pc [8:0] $end
$var wire 9 &" pcout [8:0] $end
$upscope $end
$scope module selectbranch $end
$var wire 9 '" b [8:0] $end
$var wire 1 w sel $end
$var wire 9 (" a [8:0] $end
$var reg 9 )" out [8:0] $end
$upscope $end
$scope module selectjump $end
$var wire 9 *" a [8:0] $end
$var wire 9 +" b [8:0] $end
$var wire 1 ) sel $end
$var reg 9 ," out [8:0] $end
$upscope $end
$upscope $end
$scope module RFuut $end
$var wire 16 -" aluin [15:0] $end
$var wire 1 ! clk $end
$var wire 4 ." d [3:0] $end
$var wire 16 /" dataMemin [15:0] $end
$var wire 4 0" flagin [3:0] $end
$var wire 1 " rst $end
$var wire 4 1" s1 [3:0] $end
$var wire 4 2" s2 [3:0] $end
$var wire 1 % writeReg $end
$var wire 1 $ writeRegSourceSelect $end
$var wire 1 # writeSP $end
$var wire 8 3" spout [7:0] $end
$var wire 4 4" flagout [3:0] $end
$var wire 16 5" dataRegIn [15:0] $end
$var wire 16 6" Des [15:0] $end
$var wire 16 7" B [15:0] $end
$var wire 16 8" A [15:0] $end
$scope module flaguut $end
$var wire 1 ! clk $end
$var wire 4 9" datain [3:0] $end
$var wire 1 " rst $end
$var wire 4 :" dataout [3:0] $end
$var reg 4 ;" flags [3:0] $end
$upscope $end
$scope module muxuut $end
$var wire 16 <" a [15:0] $end
$var wire 16 =" b [15:0] $end
$var wire 1 $ sel $end
$var reg 16 >" out [15:0] $end
$upscope $end
$scope module rfuut $end
$var wire 1 ! clk $end
$var wire 4 ?" d [3:0] $end
$var wire 16 @" datain [15:0] $end
$var wire 16 A" dout [15:0] $end
$var wire 1 " rst $end
$var wire 4 B" s1 [3:0] $end
$var wire 16 C" s1out [15:0] $end
$var wire 4 D" s2 [3:0] $end
$var wire 16 E" s2out [15:0] $end
$var wire 1 % writeReg $end
$var integer 32 F" i [31:0] $end
$upscope $end
$scope module spuut $end
$var wire 8 G" addrin [7:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 1 # writeSP $end
$var wire 8 H" addrout [7:0] $end
$var reg 8 I" stackaddress [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module alutb $end
$var wire 16 J" res [15:0] $end
$var wire 4 K" flags [3:0] $end
$var reg 16 L" a [15:0] $end
$var reg 3 M" aluop [2:0] $end
$var reg 16 N" b [15:0] $end
$scope module alup $end
$var wire 16 O" A [15:0] $end
$var wire 3 P" ALUOp [2:0] $end
$var wire 16 Q" B [15:0] $end
$var reg 1 R" carry $end
$var reg 4 S" flags [3:0] $end
$var reg 16 T" res [15:0] $end
$var reg 16 U" temp [15:0] $end
$upscope $end
$upscope $end
$scope module tb_aggregate $end
$var reg 1 V" clk $end
$var reg 1 W" rst $end
$upscope $end
$scope module aggregateALL $end
$scope module ALUuut $end
$scope module aluUnit $end
$upscope $end
$scope module selA $end
$upscope $end
$scope module selB $end
$upscope $end
$upscope $end
$scope module CUuut $end
$scope module alucontroller $end
$upscope $end
$upscope $end
$scope module DMuut $end
$scope module dmem $end
$upscope $end
$scope module selectaddress $end
$upscope $end
$upscope $end
$scope module IMuut $end
$upscope $end
$scope module PCuut $end
$scope module pc $end
$upscope $end
$scope module pcadd $end
$upscope $end
$scope module selectbranch $end
$upscope $end
$scope module selectjump $end
$upscope $end
$upscope $end
$scope module RFuut $end
$scope module flaguut $end
$upscope $end
$scope module muxuut $end
$upscope $end
$scope module rfuut $end
$upscope $end
$scope module spuut $end
$upscope $end
$upscope $end
$upscope $end
$scope module alutb $end
$scope module alup $end
$upscope $end
$upscope $end
$scope module tb_aggregate $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0W"
0V"
b1111111111110001 U"
b1001000100101 T"
b1 S"
1R"
b1111 Q"
b1 P"
b1001000110100 O"
b1111 N"
b1 M"
b1001000110100 L"
b1 K"
b1001000100101 J"
bx I"
bx H"
bx G"
bx F"
bx E"
bx D"
bx C"
bx B"
bx A"
bx @"
bx ?"
bx >"
bx ="
bx <"
bx ;"
bx :"
bx 9"
bx 8"
bx 7"
bx 6"
bx 5"
bx 4"
bx 3"
bx 2"
bx 1"
bx 0"
bx /"
bx ."
bx -"
bx ,"
b0xxxxxxxx +"
bx *"
bx )"
bx ("
bx '"
bx &"
bx %"
bx $"
bx #"
bx ""
bx !"
bx ~
bx }
bx |
bx {
bx z
b0xxxxxxxx y
xx
xw
bx v
bx u
bx t
b0 s
bx r
bx q
bx p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
b1 V
b1 U
bx T
bx S
bx R
b1 Q
b0xxxx P
b0xxxxxxxx O
bx N
bx M
bx L
xK
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
b0xxxx A
b0xxxxxxxx @
bx ?
bx >
bx =
bx <
bx ;
bx :
b1 9
08
b0 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
x*
x)
bx (
bx '
x&
x%
x$
x#
z"
z!
$end
#1
1W"
#5
1V"
b10 K"
b10 S"
0R"
b1110000100100000 J"
b1110000100100000 T"
b1011110111011110 U"
b100001000100010 N"
b100001000100010 Q"
b10001101000010 L"
b10001101000010 O"
#10
0V"
#15
1V"
